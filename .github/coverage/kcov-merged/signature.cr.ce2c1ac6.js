var data = {lines:[
{"lineNum":"    1","line":"# Copyright 2019-2020 @q9f"},
{"lineNum":"    2","line":"#"},
{"lineNum":"    3","line":"# Licensed under the Apache License, Version 2.0 (the \"License\");"},
{"lineNum":"    4","line":"# you may not use this file except in compliance with the License."},
{"lineNum":"    5","line":"# You may obtain a copy of the License at"},
{"lineNum":"    6","line":"#"},
{"lineNum":"    7","line":"#     http://www.apache.org/licenses/LICENSE-2.0"},
{"lineNum":"    8","line":"#"},
{"lineNum":"    9","line":"# Unless required by applicable law or agreed to in writing, software"},
{"lineNum":"   10","line":"# distributed under the License is distributed on an \"AS IS\" BASIS,"},
{"lineNum":"   11","line":"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."},
{"lineNum":"   12","line":"# See the License for the specific language governing permissions and"},
{"lineNum":"   13","line":"# limitations under the License."},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"# Implements `ECDSASignature` generation and verification for `Secp256k1`"},
{"lineNum":"   16","line":"# elliptic curves."},
{"lineNum":"   17","line":"# Ref: [cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages](https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages)"},
{"lineNum":"   18","line":"module Secp256k1::Signature"},
{"lineNum":"   19","line":"  # Signs a message and creates a signature proof using a private key."},
{"lineNum":"   20","line":"  #"},
{"lineNum":"   21","line":"  # The ECDSA signing algorithm (RFC-6979) takes as input a message `msg`"},
{"lineNum":"   22","line":"  # and a private key `priv`. It produces as output a signature, which"},
{"lineNum":"   23","line":"  # consists of pair of integers `(r, s)`, where `r` is the `x`-coordinate"},
{"lineNum":"   24","line":"  # of a random point on our curve and `s` is the signature proof."},
{"lineNum":"   25","line":"  #"},
{"lineNum":"   26","line":"  # Parameters:"},
{"lineNum":"   27","line":"  # * `msg` (`String`): A message string to sign."},
{"lineNum":"   28","line":"  # * `priv` (`BigInt`): A private key to sign with."},
{"lineNum":"   29","line":"  #"},
{"lineNum":"   30","line":"  # ```"},
{"lineNum":"   31","line":"  # sig = Secp256k1::Signature.sign \"Hello, World!\", BigInt.new(\"b795cd2c5ce0cc632ca1f65e921b9c751b363e97fcaeec81c02a85b763448268\", 16)"},
{"lineNum":"   32","line":"  # sig.r"},
{"lineNum":"   33","line":"  # # => \"63945398370917837063250848409972066837033757647691696776146735867163610886143\""},
{"lineNum":"   34","line":"  # sig.s"},
{"lineNum":"   35","line":"  # # => \"20291418537568297129028959685291490143232574306335372594306006819765182564103\""},
{"lineNum":"   36","line":"  # ```"},
{"lineNum":"   37","line":"  def self.sign(msg : String, priv : BigInt)","class":"lineCov","hits":"1","order":"281",},
{"lineNum":"   38","line":"    # Calculate the message hash, using the cryptographic hash function SHA-256."},
{"lineNum":"   39","line":"    hash = BigInt.new Hash.sha256(msg), 16","class":"lineCov","hits":"1","order":"282",},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    # Securely generate a random number `k` in the range `[1..n-1]`;"},
{"lineNum":"   42","line":"    # here: a new private key is the exact implementation of this requirement."},
{"lineNum":"   43","line":"    k = Util.new_private_key","class":"lineCov","hits":"1","order":"283",},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    # Calculate the random point `r = k * g` and take its `x`-coordinate: `r = r.x`."},
{"lineNum":"   46","line":"    r = Core.ec_mul(EC_BASE_G, k).x % EC_ORDER_N","class":"lineCov","hits":"1","order":"290",},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"    # Calculate the signature proof `s = k^-1 * (h + r * priv) % n`."},
{"lineNum":"   49","line":"    k_inv = Core.ec_mod_inv k, EC_ORDER_N","class":"lineCov","hits":"1","order":"291",},
{"lineNum":"   50","line":"    s = ((hash + r * priv) * k_inv) % EC_ORDER_N","class":"lineCov","hits":"1","order":"292",},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    # Return the signature."},
{"lineNum":"   53","line":"    ECDSASignature.new r, s","class":"lineCov","hits":"1","order":"293",},
{"lineNum":"   54","line":"  end"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"  # Verifies a signature of a message against a public key."},
{"lineNum":"   57","line":"  #"},
{"lineNum":"   58","line":"  # The algorithm to verify an ECDSA signature takes as input the signed message `msg`"},
{"lineNum":"   59","line":"  # and the signature `(r, s)` produced from `sign` and the public key `pub`,"},
{"lineNum":"   60","line":"  # corresponding to the signer\'s private key. The result is boolean."},
{"lineNum":"   61","line":"  #"},
{"lineNum":"   62","line":"  # Parameters:"},
{"lineNum":"   63","line":"  # * `msg` (`String`): A message string to verify."},
{"lineNum":"   64","line":"  # * `sig` (`ECDSASignature`): A signature to verify the message."},
{"lineNum":"   65","line":"  # * `pub` (`ECPoint`): A public key to verify the signature against."},
{"lineNum":"   66","line":"  #"},
{"lineNum":"   67","line":"  # ```"},
{"lineNum":"   68","line":"  # pub = Secp256k1::Util.restore_public_key \"03d885aed4bcaf3a8c95a57e3be08caa1bd6a060a68b9795c03129073597fcb19a\""},
{"lineNum":"   69","line":"  # msg = \"Hello, World!\""},
{"lineNum":"   70","line":"  # sig = Secp256k1::ECDSASignature.new BigInt.new(\"63945398370917837063250848409972066837033757647691696776146735867163610886143\"), BigInt.new(\"20291418537568297129028959685291490143232574306335372594306006819765182564103\")"},
{"lineNum":"   71","line":"  #"},
{"lineNum":"   72","line":"  # Secp256k1::Signature.verify msg, sig, pub"},
{"lineNum":"   73","line":"  # # => true"},
{"lineNum":"   74","line":"  # ```"},
{"lineNum":"   75","line":"  def self.verify(msg : String, sig : ECDSASignature, pub : ECPoint)","class":"lineCov","hits":"1","order":"295",},
{"lineNum":"   76","line":"    # Calculate the message hash, with the same hash function used during the signing."},
{"lineNum":"   77","line":"    hash = BigInt.new Hash.sha256(msg), 16","class":"lineCov","hits":"1","order":"296",},
{"lineNum":"   78","line":"    verify_hash hash, sig, pub","class":"lineCov","hits":"1","order":"297",},
{"lineNum":"   79","line":"  end"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"  # Verifies a signature of a message hash against a public key."},
{"lineNum":"   82","line":"  #"},
{"lineNum":"   83","line":"  # Same as `verify`, just using the hashed message directly."},
{"lineNum":"   84","line":"  #"},
{"lineNum":"   85","line":"  # Parameters:"},
{"lineNum":"   86","line":"  # * `hash` (`BigInt`): A SHA-256 hash of the message to verify."},
{"lineNum":"   87","line":"  # * `sig` (`ECDSASignature`): A signature to verify the message."},
{"lineNum":"   88","line":"  # * `pub` (`ECPoint`): A public key to verify the signature against."},
{"lineNum":"   89","line":"  #"},
{"lineNum":"   90","line":"  # Returns _true_ if signature is valid. See `verify` for usage example."},
{"lineNum":"   91","line":"  def self.verify_hash(hash : BigInt, sig : ECDSASignature, pub : ECPoint)","class":"lineCov","hits":"1","order":"298",},
{"lineNum":"   92","line":"    # Calculate the modular inverse of the signature proof: `s1 = s^{-1} % n`."},
{"lineNum":"   93","line":"    s_inv = Core.ec_mod_inv sig.s, EC_ORDER_N","class":"lineCov","hits":"1","order":"299",},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    # Recover the random point used during the signing: `R\' = (h * s1) * g + (r * s1) * pub`"},
{"lineNum":"   96","line":"    p0 = Core.ec_mul EC_BASE_G, (hash * s_inv) % EC_ORDER_N","class":"lineCov","hits":"1","order":"300",},
{"lineNum":"   97","line":"    p1 = Core.ec_mul pub, (sig.r * s_inv) % EC_ORDER_N","class":"lineCov","hits":"1","order":"301",},
{"lineNum":"   98","line":"    p = Core.ec_add p0, p1","class":"lineCov","hits":"1","order":"302",},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    # Calculate the signature validation result by comparing whether `r\' == r`."},
{"lineNum":"  101","line":"    sig.r === p.x","class":"lineCov","hits":"1","order":"303",},
{"lineNum":"  102","line":"  end"},
{"lineNum":"  103","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "run_coverage", "date" : "2021-09-29 14:18:30", "instrumented" : 16, "covered" : 16,};
var merged_data = [];
